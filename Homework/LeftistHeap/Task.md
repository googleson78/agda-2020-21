# Теглови соц. купчини (weight-biased leftist heaps)

### В текста по-надолу навсякъде под пирамида имаме предвид минимална пирамида, т.е. такава, в която наредбата е `<=`.

## Описание на структурата

"Ляво тежката пирамида" е структура от данни, използваща се най-често като приоритетна опашка.

За да служи като приоритетна опашка, тя поддържа ("бързо") операциите за намиране (`findMin`) и изтриване (`delMin`) на най-малък елемент, както и вмъкване (`insert`) на нов елемент.

Допълнително, те поддържат и бърза операция за сливане (`merge`).

За да се постигнат тези неща, те имат по-различни свойства и инварианти, от тези, които са традиционно асоциирани с двоичните пирамиди.

Започвайки от нулата:

### Дефиниции
"Ляво тежка пирамида" ще наричаме двоично дърво, за което са изпълнени две свойства:

0. "Свойството за наредбата" - стойността на всеки връх от дървото е по-малка от тази на стойностите в децата му.
1. "Ранг свойство" - За всеки връх, **рангът** на лявото му дете е **по-голям или равен** от ранга на дясното му дете.

**Рангът** е начин да даваме числова стойност на върхове/дървета.

Примери за рангове са "дължината от връх до най-близкото му листо" или пък "дължината от връх до най-дясното му листо".

В нашия случай, ще използваме "брой на върхове в поддървото" за ранг, просто защото това ще ни е по-лесно за доказване на коректност. Удобството на този ранг е, че е много по-лесно да се определи какъв ще е рангът на резултата от операцията "сливане".

"По-формалнa" дефиниция на "брой на върхове в поддървото":

0. "Ранг" на празно дърво е `0`. `rank empty = 0`
1. "Ранг" на връх с деца `l` и `r` е с едно повече от сбора на ранговете на `l` и `r`. `rank (node l r) = suc (rank l + rank r)`

Изборът на този ранг, комбиниран с "ранг свойството", гарантира че най-десният път през пирамидата е с логаритмична дължина спрямо броя на елементите в пирамидата (ако се интересувате, може да ми пишете).

Това ни позволява да имплементираме сливане със същата сложност.

За да се постигнат желаната сложност, ще пазим ранговете на всяко поддърво в корена му, вместо да ги пресмятаме всеки път.

## Задачи

За да се запознаете със структурата и операциите ѝ, ще ви дам нейна имплементация на `Agda` без никакви гаранции
в типовата система за нужните свойства от дефиницията горе.

Вашата задача след това ще е да имплементирате сами
* структурата, но с гаранция, че е изпълнено свойството за наредбата
* структурата, но с гаранция, че е изпълнено свойството за ранга
* структурата, но с гаранция, че са изпълнени едновременно свойството за наредбата и свойството за ранга (което ще означава, че вече наистина можем да наричаме формално структурата ни "weight-biased leftist heap")

### `Common.agda`

Във файла `Common.agda` са отделени функции и типове, които са нужни за повечето имплементации.

Част от функциите са имплементирани, а други трябва да попълните сами:

#### `Leq` и свойства
Срещали сме този тип вече на лекции - "по-малко или равно", но в пресметантия си вариант, а не като тип данни.


#### `Priority` и `Rank`
Типови синоними над `Nat` за наше удобство.

`Rank` ще използваме, когато говорим за рангове, докато `Priority` ще наричаме стойностите, които вмъкваме в пирамидата.


#### `min` и свойства
Функция, която връща по-малкия от два елемента. Тези са оставени за ваше забавление.

Те са нужни само за имплементациите, които имат повече гаранции за свойства.

### Имплементация без инварианти

Имплементацията можете да разгледате и в `Agda` във файла `Untyped.agda`.

Както обикновено, започваме с дефиницията на данните ни:
```agda
data Heap : Set where
  empty : Heap
  node : Rank -> Priority -> Heap -> Heap -> Heap
```

Както виждате, няма типови параметри и няма типови индекси и ни се налага да пазим рангове във върховете.

За да натъртим, че тази структура не ни гарантира нищо (me irl), ще покажем първо няколко неща, които **не са** ляво тежки пирамиди.

```agda
-- note how 2 is not < 0
wrongOrder : Heap
wrongOrder = node 2 2 (node 1 0 empty empty) empty

-- note how the rank assigned here is just wrong
wrongRank : Heap
wrongRank = node 1337 0 empty empty

-- note how the left empty has a lower rank than the right node
wrongRankprop : Heap
wrongRankprop = node 2 0 empty (node 1 5 empty empty)
```

И една истинска ляво тежка пирамида.
```agda
-- for the ordering
-- 1 <= 2
-- 1 <= 3
-- also, the ranks are correct, since 3 = 1 + (1 + 1)
-- and the rank property is preserved, since
-- 1 (rank of the right tree) <= 1 (rank of the left tree)
proper : Heap
proper = node 3 1 (node 1 2 empty empty) (node 1 3 empty empty)
```

Първо, нека си направим удобна функция за изваждане на ранга на дърво.

```agda
rank : Heap -> Rank
rank empty = 0
rank (node r _ _ _) = r
```

Целта ни сега е да имплементираме основната операция за сливане на две пирамиди.
Идеята, с която ще действаме, е следната (тя също така е и добре описана в `Purely Functional Data
Structures` нa `Chris Okasaki` - отново, свържете се с мен):

0. Знаем, че всичките пътища през пирамидата ни са "сортирани", благодарение на свойството за наредбата.
1. В частен случай, това важи и за най-десния път през пирамидата.
2. Взимайки две пирамиди, можем да слеем най-десните им пътища, запазвайки наредбата - това е много подобно на операцията, която правим, когато искаме да слеем два наредени списъка (например при merge sort).
3. Единственото нещо, което ни остава, е да запазим свойството за ранга, което правим с помощна функция.

Конкретно, имаме "smart constructor" функция (`mkNode`), която по произволен връх и две пирамиди, строи нова, за която е изпълнено ранг свойството:
```agda
mkNode : Priority -> Heap -> Heap -> Heap
mkNode x h1 h2 with decLeq (rank h1) (rank h2)
... | inl rankh1<=rankh2
  = node (suc (rank h2 +N rank h1)) x h2 h1
... | inr rankh2<=rankh1
  = node (suc (rank h1 +N rank h2)) x h1 h2
```

Нея ще използваме за "закърпване" на резултат от рекурсивното викане на сливането.

Ето я и имплементацията на самото сливане (`merge`):
```agda
{-# TERMINATING #-}
merge : Heap -> Heap -> Heap
merge empty h2 = h2
merge h1 empty = h1
merge h1@(node rank1 x1 l1 r1) h2@(node rank2 x2 l2 r2) with decLeq x1 x2
... | inl x1<=x2
  = mkNode x1 l1 (merge r1 h2)
... | inr x2<=x1
  = mkNode x2 l2 (merge r2 h1)
```

**Бележка за `{-# TERMINATING #-}`**:

Termination checker-ът на `Agda` (версия 2.6.1) не вижда, че горната дефиниция е винаги терминираща.
Има начини това да му се покаже, но за да не се занимаваме с "излишни" неща, може просто да ми повярвате за това,
а пък след това да кажем и на termination checker-а да ни "повярва" с прагмата `{-# TERMINATING #-}`.


Нека разгледаме по-подробно защо `merge` запазва "свойството на наредбата".

Да допуснем, че се е случило `x1` да е по-малката от двете стойности във върховете. Другият случай е огледален.

Свойството спрямо `x1` и новото ляво дете `l1` е запазено, защото то и преди е било ляво дете на `x1`, т.е.
знаем по допускане, че `x1` е по-малко от стойностите в `l1`.

Свойството спрямо `x1` и новото дясно дете `merge r1 h2` е запазено, защото:
* рекурсивното извикване със сигурност връща пирамида с долна граница равна на тази на `r1` или на тази на `h2`
* знаем че `x1` е по-малко от стойността в `r1`
* знаем че `x1` е по-малко от `x2`, заради сравнението което правим, но `x2` е коренът на `h2`, от което следва че `x1` е и по-малко от стойностите в `h2`
* следователно каквато и долна граница да получим за рекурсивното извикване, тя ще е по-малка от `x1`

След това, както обсъдихме и преди, извикваме `mkNode`, за да оправим ранг свойството, като `mkNode` също така и запазва
свойството за наредбата, защото то не прави друго освен най-много да смени лявото и дясното дете.

Имайки вече тази операция, всичко останало става "лесно". Вкарването на елемент в пирамида е същото като да направим
"единична" пирамида от елемента и да го слеем с пирамидата в която вмъкваме:
```agda
singleton : Priority -> Heap
singleton x = node 1 x empty empty

insert : Priority -> Heap -> Heap
insert x h = merge (singleton x) h
```

Намирането и триенето на минимален елемент са частични операции, защото може пирамидата ни да е празна.

По случайност това може да бъде коригирано, когато сложим информация за ранга в типа ни, защото тогава можем да изискваме
да ни бъде подадена непразна пирамида.

Намирането на минимален елемент е тривиално - това е елементът в корена.

Триенето също става лесно, като слеем двете подпирамиди, които имаме като деца на тази от която трием:
```agda
findMin : Heap -> Maybe Priority
findMin empty = no
findMin (node _ x _ _) = yes x

delMin : Heap -> Maybe Heap
delMin empty = no
delMin (node rank x l r) = yes (merge l r)
```

### `Ordered`

Във файла `Ordered.agda` ще намерите скелет, който да попълните.
Тук се очаква да направите `Heap` типа наподобяващ този от `Untyped.agda`, но така че по конструкция да е изпълнено
свойството за наредбата.

За вдъхновение може да погледнете какво сме правили при наредените списъци и дървета, като адаптирате
идея подобна на тяхната към това какво свойство искаме за наредбата при пирамидите.

Задачите ви са:

0. Дефинирайте типа, както разказах току-що.
1. Дайте пример за `Heap`, който изпълнява и свойството за ранга.
2. Дайте пример за `Heap`, който има грешен ранг.
3. Дайте пример за `Heap`, който **не изпълнява** свойството за ранга.
4. Имплементирайте `rank`, `mkNode`, `merge`.
5. Имплементирайте `singleton`, `weakenHeap`, `insert`. Ще трябва да помислите и какви типове да дадете за някои от тях.

    `weakenHeap` ще ни е нужно за `insert`. Идеята там вече сте я виждали - разширяваме долната граница на `Heap`-а ни, подобно
    на това което правим при `Fin`-ове, например. Освен `weakenHeap`, може да ви се наложи да доказвате и разни свойства за `min` и `Leq`.

6. Имплементирайте `findMin` и `delMin`.

    За `delMin` можете да си изберете дали да дадете "по-прецизен" тип или "по-груб тип", като по-грубият тип е по-лесен за имплементация, докато "по-прецизният" носи повече информация, но ще изисква повече труд.

### `Ranked`

Във файла `Ranked.agda` ще намерите скелет, който да попълните.
Тук се очаква да направите `Heap` типа наподобяващ този от `Untyped.agda`, но така че по конструкция да е изпълнено
свойството за ранга.

Тук не мога да ви дам вдъхновение - ще трябва да помислите как да изразите чрез типови индекси нещата, които "знаем" за ранга.

Задачите ви са:

0. Дефинирайте типа, както разказах току-що.
1. Дайте пример за `Heap`, който изпълнява и свойството за наредбата.
2. Дайте пример за `Heap`, който **не изпълнява** свойството за наредбата.
3. Имплементирайте `rank`, `mkNode`, `merge`. Ще трябва да помислите и какви типове да дадете за някои от тях.

    Тук най-вероятно ще ви се наложи да се заиграете с `rewrite`-ове и свойства свързани с естествени числа.

    Също така ще ви е нужно да използвате имплицитните аргументи за ранговете, които вероятно имате в типа си,
    както и в дефинициите на функциите.

4. Имплементирайте `singleton`, `insert`. Ще трябва да помислите и какви типове да дадете за някои от тях.

5. Имплементирайте `findMin` и `delMin`. Помислете какви типове да дадете, така че да не са частични функциите (да не връщат `Maybe Priority`).

### `Full`

Във файла `Ranked.agda` ще намерите скелет, който да попълните.
Тук се очаква да комбинирате каквото сте направили от `Ordered` и `Ranked`, за да получите нещо което изпълнява по конструкция
и свойството за наредбата и свойството за ранга.

Ако сте си имплементирали функциите и типовете както трябва досега, би трябвало това да е "механична работа" изразяваща се в омбинирането на двете дефиниции и имплементации.

Задачите ви са:

0. Дефинирайте типа, както разказах току-що.
1. Дайте пример за `Heap`, който изпълнява свойството за наредбата и свойството за ранга.
2. Пробвайте се да дадете пример за `Heap`, който чупи което и да е от двете свойства (не трябва да е възможно!).
3. Имплементирайте `rank`, `mkNode`, `merge`.

    Коментарите от горните две дефниици важат тук.

4. Имплементирайте `singleton`, `weakenHeap`, `insert`.

    Коментарите от горните две дефниици важат тук.

5. Имплементирайте `findMin` и `delMin`.

    Коментарите от горните две дефниици важат тук.

6. Имплементирайте `minimum` и `fromList`

    `minimum` и `length` ще са ви нужни за да дефинирате типа на `fromList`.
